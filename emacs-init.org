#+TITLE:  Emacs Configuration File
#+AUTHOR: Marie Simatic
#+EMAIL:  marie@simatic.org
#+PROPERTY:    results silent
#+PROPERTY:    header-args:sh  :tangle no
#+PROPERTY:    tangle ~/.emacs.d/init.el
#+PROPERTY:    eval no-export
#+PROPERTY:    comments org

* Initialisation des dépots de package & use-package
** Ajout de melpa, marmalade & gnu

#+BEGIN_SRC emacs-lisp
(require 'package)
(setq package-enable-at-startup nil)
(add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))
(add-to-list 'package-archives '("marmalade" . "http://marmalade-repo.org/packages/"))
(add-to-list 'package-archives '("gnu" . "http://elpa.gnu.org/packages/"))
(package-initialize)
#+END_SRC

** Initialisation de use-package
Use-package est un ensemble de macro permettant de manager comme un boss ses
plugins.
Outre d'obliger à correctement présenter son code, les macros ajoutent des
auto-load etc. qui permettent des meilleures performances.
[[https://github.com/jwiegley/use-package][Documentation sur le dépot Github du projet]] !

#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(eval-when-compile
  (require 'use-package))
(require 'diminish)
#+END_SRC

* Basic sane settings
** Misc
#+BEGIN_SRC emacs-lisp
; Pour ne pas avoir à taper en entier la réponse yes/no
(fset 'yes-or-no-p 'y-or-n-p)

#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq auto-revert-interval 1            ; Refresh buffers fast
      custom-file (make-temp-file "")   ; Discard customization's
      default-input-method "TeX"        ; Use TeX when toggling input method
      echo-keystrokes 0.1               ; Show keystrokes asap
      inhibit-startup-message t         ; No splash screen please
      initial-scratch-message nil       ; Clean scratch buffer
      recentf-max-saved-items 100       ; Show more recent files
      ring-bell-function 'ignore        ; Quiet
      sentence-end-double-space nil)    ; No double space

(dolist (mode
         '(column-number-mode           ; Show column number in mode line
           global-linum-mode                   ; Show line nummers
           delete-selection-mode        ; Replace selected text
           dirtrack-mode                ; directory tracking in *shell*
           recentf-mode                 ; Recently opened files
           show-paren-mode))            ; Highlight matching parentheses
  (funcall mode 1))

(setq-default fill-column 79                    ; Maximum line width
              truncate-lines t                  ; Don't fold lines
              indent-tabs-mode nil              ; Use spaces instead of tabs
              split-width-threshold 100         ; Split verticly by default
              auto-fill-function 'do-auto-fill) ; Auto-fill-mode everywhere

#+END_SRC

* Emacs autosaves settings
#+BEGIN_SRC emacs-lisp
(defvar emacs-autosave-directory
  (concat user-emacs-directory "autosaves/")
  "This variable dictates where to put auto saves. It is set to a
  directory called autosaves located wherever your .emacs.d/ is
  located.")

;; Sets all files to be backed up and auto saved in a single directory.
(setq make-backup-files t)
(setq backup-directory-alist
      `((".*" . ,emacs-autosave-directory))
      auto-save-file-name-transforms
      `((".*" ,emacs-autosave-directory t)))
#+END_SRC
* Misc Packages
#+BEGIN_SRC emacs-lisp
(use-package hydra
  :ensure t)
(use-package undo-tree
  :diminish undo-tree-mode)
(use-package org
  :config
  (setq org-src-fontify-natively t
        org-src-preserve-indentation t
        org-src-tab-acts-natively t)
  (require 'color)
  (set-face-attribute 'org-block nil :background
                      (color-darken-name
                       (face-attribute 'default :background) 3))
  
  (setq org-src-block-faces '(("emacs-lisp" (:background "#EEE2FF"))
                              ("python" (:background "#E5FFB8")))))
#+END_SRC
* Editing
** TODO Auto-completion with company
   =M-&=, =M-é= etc should work like =M-1= etc.
#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :diminish company-mode
  :bind ("M-<tab>" . company-complete)
  :config
  (global-company-mode 1)
  (setq company-idle-delay 0.3)
  (setq company-show-numbers t)
  (setq company-minimum-prefix-length 2)
  (setq company-dabbrev-downcase nil)
  (setq company-dabbrev-other-buffers t)
  (setq company-auto-complete nil)
  (setq company-dabbrev-code-other-buffers 'all)
  (setq company-dabbrev-code-everywhere t)
  (setq company-dabbrev-code-ignore-case t)
  )
#+END_SRC

** Evil Mode
*** Escaping from minibuffers and co
Escape shall allow me to escape mostly everything
#+BEGIN_SRC emacs-lisp
(define-key minibuffer-local-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-ns-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-completion-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-must-match-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-isearch-map [escape] 'minibuffer-keyboard-quit)
(global-set-key [escape] 'keyboard-quit)
#+END_SRC
I'm mapping evil escape to fj, in order to make my beautiful fingers stay on my
home row
#+BEGIN_SRC emacs-lisp
(use-package evil-escape
  :ensure t
  :diminish evil-escape-mode
  :config
  (evil-escape-mode)
  (setq-default evil-escape-key-sequence "fj")
  )
#+END_SRC

*** others packages from the evil world
**** Evil-snipe
Basically =f= and =t= on steroïd. I'm waiting a bit before remapping it to =s=
and =S= since it seems to me that I'm using the standart mapping quite a lot.
Until then =gs= and =gS= will do the trick.

#+BEGIN_SRC emacs-lisp
  (use-package evil-snipe
    :ensure t
    :diminish evil-snipe-local-mode
    :bind (:map evil-normal-state-map
                ("gs" . evil-snipe-s)
                ("gS" . evil-snipe-S))
    :config
    (evil-snipe-override-mode 1)
    (add-hook 'magit-mode-hook 'turn-off-evil-snipe-override-mode)
    (setq evil-snipe-spillover-scope 'buffer))

#+END_SRC
**** TODO Evil-leader
Quite handy in order to make all commands accessible.
I should consider extend the capabilities of the leader and / making the switch
to general.el that sounds way more classy.
#+BEGIN_SRC emacs-lisp  
(use-package evil-leader
  :ensure t
  :config
  (global-evil-leader-mode)
  (evil-leader/set-leader "SPC")
  (evil-leader/set-key
    "g"  'magit-status
    "O" 'ace-window
    "SPC" 'counsel-M-x
    "o" 'other-window
    "b" 'ivy-switch-buffer
    "B" 'projectile-ibuffer
    "s" 'evil-snipe-s
    "S" 'evil-snipe-S
    "f" 'counsel-projectile-find-file))
#+END_SRC
**** TODO others evil universe plugins
I have to experiment a bit more with them.
#+BEGIN_SRC emacs-lisp  
(use-package evil-surround
  :ensure t
  :config
  (global-evil-surround-mode 1))
(use-package evil-matchit
  :ensure t
  :config
  (global-evil-matchit-mode 1))
(use-package evil-args
  :ensure t
  :config
  ;; bind evil-args text objects
  (define-key evil-inner-text-objects-map "a" 'evil-inner-arg)
  (define-key evil-outer-text-objects-map "a" 'evil-outer-arg))
#+END_SRC
*** My evil configuration !
#+BEGIN_SRC emacs-lisp  
(use-package evil
  :ensure t
  :commands (evil-mode)
  :bind (:map evil-normal-state-map
              ("RET" . evil-scroll-page-down)
              ("DEL" . evil-scroll-page-up))
  :config
  (evil-mode 1)

  ;; managing which mode should evil go into
  (dolist (mode '(term-mode
		  bs-mode
                  magit-mode
                  neotree-mode
                  help-mode
                  ibuffer-mode))
    (add-to-list 'evil-emacs-state-modes mode))

  (evil-set-initial-state 'git-commit-mode 'insert)

  ;; accept all emacs key binding in evil insert state
  (setcdr evil-insert-state-map nil)
  (define-key evil-insert-state-map
    (read-kbd-macro evil-toggle-key) 'evil-normal-state)
  (define-key evil-insert-state-map [escape] 'evil-normal-state)
  (define-key evil-insert-state-map (kbd "C-w") 'evil-delete-backward-word)

  ;; make * and # behave with swiper
  (define-key evil-normal-state-map (kbd "*")
    (lambda () (interactive) (swiper (format "\\<%s\\>" (thing-at-point 'symbol)))))
  (define-key evil-normal-state-map (kbd "#")
    (lambda () (interactive) (swiper (format "\\<%s\\>" (thing-at-point 'word)))))

  (define-key evil-insert-state-map (kbd "M-k") 'evil-normal-state)
  (define-key evil-replace-state-map (kbd "M-k") 'evil-normal-state))
#+END_SRC

* Navigation
** Project Management
*** Projectile
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure t
  :diminish projectile-mode
  :bind (:map evil-normal-state-map
              ("gp" . projectile-commander))
  :config
  (use-package counsel-projectile
    :ensure t
    :bind (:map evil-normal-state-map
                ("gF" . counsel-projectile-find-file)
                ("gP" . counsel-projectile-switch-project))
    :config
    (counsel-projectile-on))
  (projectile-mode))
#+END_SRC
*** Versionning
#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :bind (("C-x g" . magit-status)))

(use-package git-gutter
  :ensure t
  :config
  ;; activate git gutter everywhere
  (global-git-gutter-mode t)
  
  (git-gutter:linum-setup)
  (custom-set-variables
   '(git-gutter:update-interval 2)
   '(git-gutter:lighter " GG")
   '(git-gutter:modified-sign "  ")
   '(git-gutter:added-sign "++")
   '(git-gutter:deleted-sign "--")
   '(git-gutter:hide-gutter t))     ;; Hide Gutter if there is no changes

  (set-face-background 'git-gutter:modified "gray") ;; background color
  (set-face-foreground 'git-gutter:added "green")
  (set-face-foreground 'git-gutter:deleted "red")
  )

#+END_SRC
** Ibuffer
*** Hydra configuration for ibuffer
#+BEGIN_SRC emacs-lisp
  (defhydra hydra-ibuffer-main (:color pink :hint nil)
    "
 ^Navigation^ | ^Mark^        | ^Actions^        | ^View^
-^----------^-+-^----^--------+-^-------^--------+-^----^-------
  _k_:    ʌ   | _m_: mark     | _D_: delete      | _g_: refresh
 _RET_: visit | _u_: unmark   | _S_: save        | _s_: sort
  _j_:    v   | _*_: specific | _a_: all actions | _/_: filter
-^----------^-+-^----^--------+-^-------^--------+-^----^-------
"
    ("j" ibuffer-forward-line)
    ("RET" ibuffer-visit-buffer :color blue)
    ("k" ibuffer-backward-line)

    ("m" ibuffer-mark-forward)
    ("u" ibuffer-unmark-forward)
    ("*" hydra-ibuffer-mark/body :color blue)

    ("D" ibuffer-do-delete)
    ("S" ibuffer-do-save)
    ("a" hydra-ibuffer-action/body :color blue)

    ("g" ibuffer-update)
    ("s" hydra-ibuffer-sort/body :color blue)
    ("/" hydra-ibuffer-filter/body :color blue)

    ("o" ibuffer-visit-buffer-other-window "other window" :color blue)
    ("q" ibuffer-quit "quit ibuffer" :color blue)
    ("." nil "toggle hydra" :color blue))

  (defhydra hydra-ibuffer-mark (:color teal :columns 5
                                       :after-exit (hydra-ibuffer-main/body))
    "Mark"
    ("*" ibuffer-unmark-all "unmark all")
    ("M" ibuffer-mark-by-mode "mode")
    ("m" ibuffer-mark-modified-buffers "modified")
    ("u" ibuffer-mark-unsaved-buffers "unsaved")
    ("s" ibuffer-mark-special-buffers "special")
    ("r" ibuffer-mark-read-only-buffers "read-only")
    ("/" ibuffer-mark-dired-buffers "dired")
    ("e" ibuffer-mark-dissociated-buffers "dissociated")
    ("h" ibuffer-mark-help-buffers "help")
    ("z" ibuffer-mark-compressed-file-buffers "compressed")
    ("b" hydra-ibuffer-main/body "back" :color blue))

  (defhydra hydra-ibuffer-action (:color teal :columns 4
                                         :after-exit
                                         (if (eq major-mode 'ibuffer-mode)
                                             (hydra-ibuffer-main/body)))
    "Action"
    ("A" ibuffer-do-view "view")
    ("E" ibuffer-do-eval "eval")
    ("F" ibuffer-do-shell-command-file "shell-command-file")
    ("I" ibuffer-do-query-replace-regexp "query-replace-regexp")
    ("H" ibuffer-do-view-other-frame "view-other-frame")
    ("N" ibuffer-do-shell-command-pipe-replace "shell-cmd-pipe-replace")
    ("M" ibuffer-do-toggle-modified "toggle-modified")
    ("O" ibuffer-do-occur "occur")
    ("P" ibuffer-do-print "print")
    ("Q" ibuffer-do-query-replace "query-replace")
    ("R" ibuffer-do-rename-uniquely "rename-uniquely")
    ("T" ibuffer-do-toggle-read-only "toggle-read-only")
    ("U" ibuffer-do-replace-regexp "replace-regexp")
    ("V" ibuffer-do-revert "revert")
    ("W" ibuffer-do-view-and-eval "view-and-eval")
    ("X" ibuffer-do-shell-command-pipe "shell-command-pipe")
    ("b" nil "back"))

  (defhydra hydra-ibuffer-sort (:color amaranth :columns 3)
    "Sort"
    ("i" ibuffer-invert-sorting "invert")
    ("a" ibuffer-do-sort-by-alphabetic "alphabetic")
    ("v" ibuffer-do-sort-by-recency "recently used")
    ("s" ibuffer-do-sort-by-size "size")
    ("f" ibuffer-do-sort-by-filename/process "filename")
    ("m" ibuffer-do-sort-by-major-mode "mode")
    ("b" hydra-ibuffer-main/body "back" :color blue))

  (defhydra hydra-ibuffer-filter (:color amaranth :columns 4)
    "Filter"
    ("m" ibuffer-filter-by-used-mode "mode")
    ("M" ibuffer-filter-by-derived-mode "derived mode")
    ("n" ibuffer-filter-by-name "name")
    ("c" ibuffer-filter-by-content "content")
    ("e" ibuffer-filter-by-predicate "predicate")
    ("f" ibuffer-filter-by-filename "filename")
    (">" ibuffer-filter-by-size-gt "size")
    ("<" ibuffer-filter-by-size-lt "size")
    ("/" ibuffer-filter-disable "disable")
    ("b" hydra-ibuffer-main/body "back" :color blue))
#+END_SRC
*** General settings of ibuffer
#+BEGIN_SRC emacs-lisp
(use-package ibuffer
  :bind (("C-x C-b" . ibuffer)
         ("M-i" . next-buffer)
         ("M-o" . previous-buffer))
  :bind (:map evil-normal-state-map
              ("gB" . ibuffer)
              ("gb" . ibuffer-jump-to-buffer))
  :bind (:map ibuffer-mode-map
              (";" . hydra-ibuffer-main/body))
  :config

    (add-hook 'ibuffer-hook #'hydra-ibuffer-main/body)
  )
#+END_SRC
** Window / Split management
*** Eyebrowse
#+BEGIN_SRC emacs-lisp
(use-package eyebrowse
  :ensure t
  :config
  (eyebrowse-mode t)
  (eyebrowse-setup-opinionated-keys))
#+END_SRC
*** Acewindow
#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :ensure t
  :config
  (setq aw-dispatch-always t)
  (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)))
#+END_SRC
*** Enhanced search with ivy-mode (Counsel & Swiper !)
#+BEGIN_SRC emacs-lisp
(use-package ivy
  :ensure t
  :diminish ivy-mode
  :init
  (setq ivy-use-virtual-buffers t)
  (setq ivy-count-format "(%d/%d) ")
  :config
  (ivy-mode 1)
  :bind (("C-x C-r" . counsel-recentf)
	 ("C-x b" . ivy-switch-buffer)
	 ("C-c v" . ivy-push-view)
	 ("C-c V" . ivy-pop-view)
	 ("C-s" . counsel-grep-or-swiper)
	 ("M-s" . swiper-all)
	 ("M-x" . counsel-M-x)
	 ("C-x C-t" . counsel-load-theme)
	 ("M-a" . counsel-ag)
	 ("M-é" . counsel-imenu)
	 ("C-x C-f" . counsel-find-file)
	 ("M-r" . ivy-resume)))
#+END_SRC

*** Search on steroid with Avy
#+BEGIN_SRC emacs-lisp
(use-package avy
  :ensure t
  :config
  (setq avy-case-fold-search nil)       ;; case sensitive makes selection easier
  :bind (:map evil-normal-state-map
              ("gl" . avy-goto-line)
              ("gr" . avy-goto-char-timer)
              ("gw" . avy-goto-word-1)))

#+END_SRC

** File brower
#+BEGIN_SRC emacs-lisp
(use-package all-the-icons
  :ensure t)

(use-package neotree
  :ensure t
  :commands (neotree-toggle)
  :config
  ;; (setq neo-theme (if (display-graphic-p) 'icons 'arrow))
  )

#+END_SRC
* General looking tweaks

** Theming
Lets begin by installing some themes that I really enjoy
#+BEGIN_SRC emacs-lisp

(use-package solarized-theme
  :ensure t
  :init
  (setq solarized-use-more-italic t))

(use-package gruvbox-theme
  :ensure t)
#+END_SRC

Package theme-looper, for easy looping throught my favorites themes.
#+BEGIN_SRC emacs-lisp
(use-package theme-looper
  :ensure t
  :config
  (theme-looper-set-theme-set (list 'solarized-light 'solarized-dark
				    'gruvbox)))
#+END_SRC

And finally, lets load a theme by default. (and cry that gruvbox light isn't
yet ported on emacs.
#+BEGIN_SRC emacs-lisp
(load-theme 'gruvbox t)
#+END_SRC

** UI functions

#+BEGIN_SRC emacs-lisp
(use-package smart-mode-line
  :ensure t
  :init
  (setq sml/no-confirm-load-theme t)
  :config
  (sml/setup))
(dolist (mode
         '(tool-bar-mode                ; No toolbars, more room for text
           scroll-bar-mode              ; No scroll bars either
           blink-cursor-mode))          ; The blinking cursor gets old
  (funcall mode 0))
#+END_SRC

** Tiny Menu


#+BEGIN_SRC emacs-lisp
(use-package tiny-menu
  :ensure t
  :bind (("C-x m" . tiny-menu))
  :config
  (setq tiny-menu-items '(("buffer-menu"
			   ("Buffer operations"
			    ((?k "Kill" kill-this-buffer "buffer-menu")
			    (?q "Quit Menu" nil "quit"))))
			  ("projectile-menu"
			   ("Projectile"
			    ((?p "project" counsel-projectile-switch-project)
			     (?b "switch to buffer" counsel-projectile-switch-to-buffer)
			     (?f "file" counsel-projectile-find-file)
			     (?i "ibuffer" projectil-ibuffer)
			     (?d "dired" projectile-dired)
			     (?a "activate" projectile-mode))))
			  ("theme-changer"
			   ("Change theme"
			    ((?j "next theme" theme-looper-enable-next-theme "theme-changer")))))))
#+END_SRC

* Vrac
** Some informations
#+BEGIN_SRC emacs-lisp
(set-language-environment "UTF-8")
(setq user-full-name "Marie Simatic"
      user-mail-address "marie@simatic.org")

#+END_SRC
